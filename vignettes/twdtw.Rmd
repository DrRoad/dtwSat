---
title: "Timw-Weighted Dynamic Time Warping"
author: "Victor Maus^[National Institute for Space Research, Avenida dos Astronautas 1758, 12227010, São José dos Campos, Brazil.], ^[Institute for Geoinformatics, University of Münster, Heisenbergstraße 2, 48149 Münster, Germany]"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
bibliography: references.bib
vignette: >
  %\VignetteIndexEntry{Timw-Weighted Dynamic Time Warping}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r twdtw-method, echo=FALSE}
knitr::opts_chunk$set(
  warning = FALSE,
  message = FALSE,
  error = FALSE,
  results = "hide"
)
```


```{r, echo = FALSE, eval = TRUE}
library(dtwSat)
library(ggplot2)
library(gridExtra)
library(scales)
library(grid)
library(reshape2)
library(raster)

font_size = 8 
font_family = "Helvetica"
page_width = 5.590551#in #14.2#cm
page_height = 9.173228#in 23.3#cm

# DTW Alignment 
weight.fun = logisticWeight(alpha = -0.1, beta = 100)
alig1 = twdtw(x=waveletSmoothing(template), patterns = patterns.list['Soybean'], span = 130, keep = TRUE) 
# TWDTW Alignment 
alig2 = twdtw(x=waveletSmoothing(template), patterns = patterns.list['Soybean'], weight.fun = weight.fun, span = 130, keep = TRUE)

res = c(alig1@alignments["Soybean"], alig2@alignments["Soybean"])
names(res) =  c("DTW", "TWDTW")
twdtw_x_dtw = new("twdtw", call=match.call(), alignments=res)
```

Time-Weighted Dynamic Time Warping is a variation of the classical Dynamic Time Warping (DTW) algorithm that includes a time-weight as constraint to perform a time series alignment. It works by comparing a temporal pattern of a known event observed through a sequence of satellite images (e.g. the phenological cycle of the vegetation) to an unknown long-term satellite time series. This is particularly useful when the temporal pattern is much shorter than the target time series, and to compare time series with strong time dependency, such as phenological the stages of vegetation. 

### Introduction 

Remote sensors have collected large amount of data bringing unique information about the Earth. This archive of satellite images builds up into time series, which allow studying and better understanding the Earth system. However, inter- and intra-annual variability of some Earth system processes combined with noise and gaps in remotely sensed data have challenged the satellite data analysis [@Reed:1994; @Huete:1997, @Huete:2002]. Recently, there has been a great effort to develop new methods capable of dealing with irregularly sampled and out-of-phase remote sensing time series. Methods based on Dynamic Time Warping (DTW), for example, are flexible to handle irregular sampling and out-of-phase time series, and they have achieved significant results in time series data mining [@Rabiner:1993; @Berndt:1994; @Keogh:2005; @Muller:2007]. Originally, DTW was developed to compare speech records [@Velichko:1970; @Sakoe:1971; @Sakoe:1978] but it has shown great potential in other areas, such as, in remote sensing [@Petitjean:2012; 

The original dynamic time warping method works well for shape matching but it is not suited for remote sensing time series classification. This is because it disregards the temporal range when finding the best alignment between two time series. Each land cover class has a specific phenological cycle, and therefore, a good time-series land cover classifier needs to balance between shape matching and temporal alignment. To that end, @Maus:2016 included a temporal weight to the original dynamic time warping method that accounts for seasonality of land cover types. 

Here we describe the Time-Weighted Dynamic Time Warping algorithm such as implemented in [dtwSat](https://cran.r-project.org/web/packages/dtwSat/index.html) package. The next sections show the steps of the algorithm highlighting the differences between TWDTW and original Dynamic Time Warping algorithm. 

### Notation
Let $\mathcal{X}$ be a satellite image time series, such that, $\mathcal{X}=\{\mathbf{x}(t_1), \mathbf{x}(t_2),\, ...,\, \mathbf{x}(t_m)\}$ where $t$ is the time when a set of measurements $\mathbf{x}$ where taken, *i.e.* $\mathbf{x}(t)=\{x_1(t),\, x_2(t),\, ...,\, x_q(t)\}$ and $q$ is the number of measurements. Let us define a second time series $\mathcal{Y}=\{\mathbf{y}(t_1), \mathbf{y}(t_2),\, ...,\, \mathbf{y}(t_n)\}$ with the same attributes as $\mathcal{X}$, however much shorter than that, *i.e* $n \ll m$. If $\mathcal{X}$ is an unknown time series and $\mathcal{Y}$ a well known temporal profile of an event in the earth surface observed through satellite images, we might be interested in the following questions: *i)* How many intervals of $\mathcal{X}$ are similar to $\mathcal{Y}$?, and *ii)* How similar to $\mathcal{Y}$ these intervals of $\mathcal{X}$ are? The TWDTW method finds the matching points and computes an associated distance measure for each subinterval of $\mathcal{X}$ that is similar to $\mathcal{Y}$, such as illustrated bellow
```{r twdtw-example, echo = FALSE, eval = TRUE, fig.path='figure/', fig.width=page_width, fig.align='center', fig.cap='Alignments of the pattern $\\mathcal{Y}$ to subintervals of a vegetation index time series $\\mathcal{X}$. The solid black line is the long-term time series, the colored lines are the different alignments of the same pattern ordered by their associated distance measure, and the gray dashed lines are the matching points.'}
aux = alig2
n = 1:nrow(getAlignments(aux))
names(aux@alignments) = "Alignment"
df_dist = getAlignments(alig2)
df_dist$label = paste("Distance:",round(df_dist$distance,2))
df_dist$y = 1.8 
plotMatch(aux, attr="evi", p.names = rep("Alignment",length(n)), n = n) + 
  ylab("Time series                 Pattern") + 
  geom_text(data=df_dist, mapping = aes_string(x='to', y='y', label='label'),
            size = 3, family=font_family) +
  theme(text = element_text(size = font_size, family=font_family))
```
Note that alignments are independent from each other, therefore we can use the distance measure to rank the them. This is important because we use this distance measure to perform the classification of the subintervals. 

In the workflow bellow we show the TWDTW steps that will be better discussed in the following sections. 
```{r twdtw-workflow, echo = FALSE, eval = TRUE, fig.path='figure/', fig.width=page_width, fig.height=page_width/12, fig.align='center', fig.cap='Workflow of TWDTW algorithm to find the alignments between two time series.'}
library(png)
library(grid)
grid.raster(readPNG("twdtw_algorithm.png"))
```


### Local cost matrix computation

As showed before the algorithm starts by computing a local cost matrix $\Psi(\mathcal{X},\mathcal{Y})$ $n$-by-$m$, whose elements are given by
$$
    \psi_{j,i} = 
    \phi(\mathbf{x}(t_j),\mathbf{y}(t_i))+
    \omega(t_j,t_i),
    \;j=1,...,m,
    \; \textrm{and}\;i=1,...,n.
    \label{eq:local_cost}
$$
Where $\phi$ is the distance function and $\omega$ is the time weight function. Most of the DTW approaches define $\phi$ as an Euclidean distance. The time weight $\omega$ is what distinguishes TWDTW from DTW, *i.e* if $\omega=0$ then the equation above returns to the original DTW formulation. The time weight $\omega$ depends on the time $t$ when the satellite image was collected. @Maus:2016 proposed two functions to compute the temporal weight, a linear with slope $\theta$
$$
    \omega_{j,i} = \theta g(t_j,t_i),
    \label{eq:lineartw}
$$
and a logistic model with midpoint $\beta$, and steepness $\alpha$, given by
$$
    \omega_{j,i} = \frac{1}{1 + e^{-\alpha(g(t_j,t_i)-\beta)} }.
    \label{eq:nonlineartw}
$$
The function $g$ is the absolute difference in days between the dates $t_j$ in the time series $\mathcal{X}$ and $t_i$ in the time series $\mathcal{Y}$, *i.e* $|t_j-t_i|$. These two time-weight functions are illustrated bellow 
```{r time-weight-functions, echo = FALSE, eval = TRUE, fig.path='figure/', fig.width=page_width, fig.align='center', fig.cap='Illustration of the liner time-weight (dashed line) and logistic time-weight (solid line). The linear function implies high cost for small time differences, while the logistic function is more flexible for small time differences.'}
log_fun = logisticWeight(alpha = -0.1, beta = 70)
lin_fun = linearWeight(a = 1/(266/2))
Difference = 0:(266/2)
df_weight = data.frame(Difference, Logistic=log_fun(Difference), Linear=lin_fun(Difference))
df_weight = melt(df_weight, id.vars = "Difference")
ggplot(df_weight, aes_string(x="Difference", y="value", group="variable", linetype="variable")) + 
  geom_line() + ylab("Weight") + xlab("Time difference (days)") + 
  theme(text = element_text(size = font_size, family=font_family))
```

The time weight is crucial for an accurate identification of temporal patterns bounded to seasons [@Maus:2016], such as the phenological cycle of the vegetation observed through remote sensing time series [@Zhang:2003]. The time weight creates a global constraint reducing the number of low-cost paths in the local cost matrix, consequently, reducing also the chances of temporal inconsistent matching. In the figure bellow we illustrate the difference between the local cost matrices of DTW and Time-Weighted DTW. 
```{r local-cost-matrix, echo = FALSE, eval = TRUE, fig.path='figure/', fig.width=page_width, fig.align='center', fig.cap='DTW local cost matrix (top) and TWDTW local cost matrix (bottom). The dark areas in the matrices indicate the low-cost candidate paths.'}
plot(twdtw_x_dtw, type="cost", matrix.name = "localMatrix") + 
  theme(text = element_text(size = font_size, family=font_family)) + 
  xlab("j") + ylab("i")
```


### Accumulated cost matrix computation
The next step of the algorithm is the computation of an accumulated cost matrix $\mathbf{D}$ based on the local cost matrix $\Psi$. The accumulated cost matrix $\mathbf{D}$ results from a recursive sum of minimal distances under a local constraint given by the step type. Here we use a symmetric step given by

$$
      d_{i,j} =  \psi_{i,j} + 
                  min\left\{\begin{array}{l}
                    d_{j  , i-1} \\
                    d_{j-1, i-1} \\
                    d_{j-1, i  }
                  \end{array}\right.
$$
and its boundaries conditions 
$$
  d_{j,i} = \left\{
         \begin{array}{lll}
            \psi_{j,i}              & j=1   ,& i = 1 \\
            \sum_{k=1}^j \psi_{k,i} & i = 1 ,& 1 < j \leq m \\
            \sum_{k=1}^i \psi_{j,k} & j = 1 ,& 1 < i \leq n  
          \end{array}
      \right.
      \label{eq:dtwboundary}
$$

This symmetric step uses only the first order neighbors to compute the recursive sum of minimal distances, *i.e* $min(d_{j,i-1}, d_{j-1,i-1}, d_{j-1,i})$, as we can see in the following graphical representation 
```{r symmtric-step, echo = FALSE, eval = TRUE, fig.path='figure/', fig.width=page_width/4, fig.height=page_width/8, fig.align='center'}
grid.raster(readPNG("step_symmetric_step.png"))
```

Using these conditions the algorithm runs a recursive sum of minimal distances using $\Psi$ as input. The result of this computation is the accumulated cost matrix $\mathbf{D}$, illustrated bellow. 
```{r cost-matrix, echo = FALSE, eval = TRUE, fig.path='figure/', fig.width=page_width, fig.align='center', fig.cap='DTW accumulated cost matrix (top) and TWDTW accumulated cost matrix (bottom). The dark color "valleys" indicate the low-cost paths, *i.e* the candidates to match the temporal pattern to the long-term time series.'}
plot(twdtw_x_dtw, type="cost", matrix.name = "costMatrix") + 
  theme(text = element_text(size = font_size, family=font_family)) + 
  xlab("j") + ylab("i")
```

Other step types and global constraints have been proposed to compute the accumulated cost matrix [see @Sakoe:1978; @Rabiner:1993; @Giorgino:2009; @Petitjean:2012]. However, we consider the time weighting proposed by [@Maus:2015] sufficient constraint for satellite image time series analysis, and therefore the [dtwSat](https://cran.r-project.org/web/packages/dtwSat/index.html) implementation does not address other global constraint algorithms.


### Subintervals and reverse algorithm

The reverse algorithm traces the time series alignments through the low-cost paths ‘’valleys’’ of the accumulated cost matrix. It is a backward computation because it begins in the last point of each alignment, *i.e.* it starts from the last line of the accumulated cost matrix $d_{j,i=n}, j=1,...,m$. For that we first find the minimum points in last line of the matrix $\mathbf{D}$, such that
$$
  b_k = argmin_k(d_{j,n}),\quad\;j=1,...,m\;\mathrm{and}\;k=1,...,K,\\
      \label{eq:minpoints}
$$
where $b_k$ is the index of the last point of the alignment $k$, and $K$ is the number of minimum points in last line of the accumulated cost matrix. Each candidate in the last line of $\mathbf{D}$ produces an alignment associated with a TWDTW distance given by $\delta_k = d_{b_k,n}$. These already answers our motivating questions, *i)* $K$ is the number of intervals of $\mathcal{X}$ that are similar to $\mathcal{Y}$, and *ii)* $\delta_k$ gives their similarity.

However, if we want to have the complete information of the alignments (including matching points, length, and starting dates) we need to run the reverse algorithm and map the warping path $\mathbf{P}_k=(p_1,...,p_L)$ along the $kth$ low-cost ''valley'' in $\mathbf{D}$. The algorithm starts in $p_{l=L} = (j=b_k,i=n)$ and ends when $i=1$, *i.e.* $p_{l=1} = (j=a_k, i=1)$. Therefore, $\mathbf{P}_k$ contains the matching points of the alignment between $\mathcal{Y}$ and the $kth$ interval of $\mathcal{X}$, such that $p_L$ denotes the last pair of indices $(j=b_k,i=n)$ and $p_1$ the first pair of indices $(j=a_k, i=1)$. Note that the backward algorithm uses the same step type as the accumulated cost computation, which implies the monotonicity condition [@Muller:2007], *i.e.* the alignment preserves the order of the time series. The reverse algorithm using symmetric steps is given by
$$
    p_{l-1} = \left\{
    \begin{array}{ll}
        (a_k=j, i) & if\quad i=1 \\
        (j, i-1) & if\quad j=1 \\
        argmin(d_{j,i-1},d_{j-1,i-1}, d_{j-1,i}) & \textrm{otherwise}
    \end{array}
    \right.
    \label{eq:dtwoptimalwarping}
$$

The reverse algorithm maps each low-cost path independently from each other. In the illustration bellow we present all low-cost paths mapped using DTW and TWDTW approaches. Note that DTW has weaker time constraint than TWDTW, therefore, it finds more alignments than the least. Some of the DTW alignments have an inconsistent match to the period of the year. Our temporal pattern ranges from November to March, therefore, it should not be found in other periods of the year as we see, for example, in the DTW alignments 1 and 2.
```{r minimum-paths-dtw-twdtw, echo = FALSE, eval = TRUE, fig.path='figure/', fig.width=page_width, fig.align='center', fig.cap='Low-cost paths in the accumulated cost matrix $\\mathbf{D}$ using the reverse algorithm for DTW (top) and TWDTW (bottom). The red lines are the low-cost paths; the dashed white lines show the subintervals of $\\mathcal{X}$ matching $\\mathcal{Y}$; $a_k$ is the start of the $kth$ alignment; and $b_k$ is the end of the $kth$ alignment.'}
n1 = 1:nrow(getAlignments(alig1))
df1.path = do.call("rbind", lapply(n1, function(i){
  data.frame(getMatches(alig1)[[1]][[i]], alignment=i, 
             a=min(getMatches(alig1)[[1]][[i]]$index2),
             b=max(getMatches(alig1)[[1]][[i]]$index2) )
}))
df1.ab = df1.path[df1.path$index1==min(df1.path$index1),]
df1.ab = rbind(df1.ab, data.frame(index1=max(df1.path$index1), df1.ab[,-1]))
df1.text = melt(df1.ab[df1.ab$index1==max(df1.path$index1), c("index1","a","b")], id="index1")
df1.text$alignment = df1.ab$alignment
df1.text$value = df1.text$value + c(rep(-2, length(n1)), rep(3, length(n1)))
df1.text$index1 = df1.text$index1 + c(rep(-max(df1.path$index1)+2, length(n1)), rep(-.4, length(n1)))
df1.text$Pattern = "DTW"
df1.ab$Pattern = "DTW"
df1.path$Pattern = "DTW"

n2 = 1:nrow(getAlignments(alig2))
df2.path = do.call("rbind", lapply(n2, function(i){
  data.frame(getMatches(alig2)[[1]][[i]], alignment=i, 
             a=min(getMatches(alig2)[[1]][[i]]$index2),
             b=max(getMatches(alig2)[[1]][[i]]$index2) )
}))
# df2.path$index1 = df2.path$index1 + max(df1.path$index1)
df2.ab = df2.path[df2.path$index1==min(df2.path$index1),]
df2.ab = rbind(df2.ab, data.frame(index1=max(df2.path$index1), df2.ab[,-1]))
df2.text = melt(df2.ab[df2.ab$index1==max(df2.path$index1), c("index1","a","b")], id="index1")
df2.text$alignment = df2.ab$alignment
df2.text$value = df2.text$value + c(rep(-2, length(n2)), rep(3, length(n2)))
df2.text$index1 = df2.text$index1 + c(rep(-max(df2.path$index1)+2, length(n2)), rep(-.4, length(n2))) 
df2.text$index1 = df2.text$index1 + max(df1.text$index1)
df2.ab$index1 = df2.ab$index1 + max(df1.ab$index1)
df2.path$index1 = df2.path$index1 + max(df1.path$index1)

df2.text$Pattern = "TWDTW"
df2.ab$Pattern = "TWDTW"
df2.path$Pattern = "TWDTW"

df.ab =   rbind(df1.ab, df2.ab)
df.text = rbind(df1.text, df2.text)
df.path = rbind(df1.path, df2.path)
  
plot(x=twdtw_x_dtw, type="cost", matrix.name="costMatrix") + 
  theme(text = element_text(size = font_size, family=font_family)) + 
  xlab("j") + 
  ylab("i") + 
  geom_path(data=df.path, aes_string(y='index1', x='index2', group='alignment'), colour = "red") + 
  geom_line(data=df.ab, aes_string(y='index1', x='a', group='alignment'), 
            colour = "white", linetype = 2) + 
  geom_line(data=df.ab, aes_string(y='index1', x='b', group='alignment'), 
            colour = "white", linetype = 2) +
  geom_text(data = df.text, aes(y=index1, x=value, 
            label=paste(variable, "[", alignment, "]", sep = "")), parse = TRUE, size=3)
```

The inconsistent temporal matching becomes more evident in the illustration bellow, where we show the matching points of the alignments of DTW and TWDTW. We see that DTW fitted the temporal pattern to the first and second phenological cycles in the same year, while this temporal pattern should be found only in the first cycle, from November to March. 
```{r match-dtw, echo = FALSE, eval = TRUE, fig.path='figure/', fig.width=page_width, fig.height=page_width/1.5, fig.align='center', fig.cap='Illustration showing all alignments found by DTW (top) and by TWDTW (bottom). The solid black line is the long-term time series, the colored lines are the different alignments of the same pattern, and the gray dashed lines are the matching points.'}
n1 = 1:nrow(getAlignments(alig1))
gp1 = plotMatch(alig1, attr="evi", p.names = rep("Soybean",length(n1)), n = n1)
gp1$facet = facet_wrap(~method, ncol = 1)
gp1$data$method = "DTW"
gp1$layers[[2]]$data$method = "DTW"
gp1$layers[[3]]$data$method = "DTW"
n2 = 1:nrow(getAlignments(alig2))
gp2 = plotMatch(alig2, attr="evi", p.names = rep("Soybean",length(n2)), n = n2) 
gp2$facet = facet_wrap(~method, ncol = 1)
gp2$data$method = "TWDTW"
gp2$layers[[2]]$data$method = "TWDTW"
gp2$layers[[3]]$data$method = "TWDTW"
gp = gp1 
gp$data = rbind(gp1$data, gp2$data)
gp$layers[[2]]$data = rbind(gp1$layers[[2]]$data, gp2$layers[[2]]$data)
gp$layers[[3]]$data = rbind(gp1$layers[[3]]$data, gp2$layers[[3]]$data)
gp + theme(text = element_text(size = font_size, family=font_family),
           legend.position = "none") + ylab("Vegetation index")
```


### Conclusions

The TWDTW algorithm is suitable for applications of remote sensing time series where the temporal variation is more important than the spatial variation for classifying remote sensing data sets. The inclusion of a temporal restriction allows for phase-shifts due to seasonal changes of natural and cultivated vegetation types. 

### References

