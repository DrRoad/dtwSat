---
title: "Producing a land cover map"
author: "Victor Maus^[National Institute for Space Research, Avenida dos Astronautas 1758, 12227010, São José dos Campos, Brazil.], ^[Institute for Geoinformatics, University of Münster, Heisenbergstraße 2, 48149 Münster, Germany]"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
bibliography: references.bib
vignette: >
  %\VignetteIndexEntry{Land use classification using dtwSat}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r lucc, echo=FALSE}
knitr::opts_chunk$set(
  warning = FALSE,
  message = FALSE,
  error = FALSE,
  results = "hide"
)
```


In this section we present an application of TWDTW for land use and land cover changes analysis using satellite image time series. We use a set unclassified satellite image time series and temporal patterns based on field samples. We show step-by-step how to create the set of temporal patterns using field samples of land use classes, and how to perform the TWDTW analysis for a satellite image time series using the raster interface. In the end of this chapter we also present a land use and land cover changes analysis as well as the accuracy assessment. The satellite images and the field samples used in the examples come with \pkg{dtwSat} package. 

The data for for out TWDTW analysis are: *i)* a sequence of satellite images ordered by time, and *ii)* a set of ground truth samples. The are is located in the tropical forest, in Mato Grosso, Brazil, and the time domain is from 2007 to 2013. The satellite images were extracted from the MODIS product MOD13Q1 collection 5 [@Friedl:2010] and include vegetation indexes "ndvi", "evi", and original bands "nir", "red", "blue", and "mir". This product has 250 m spatial and 16 day temporal resolution, that means a sequence of 160 images with 999 pixels each, *i.e.* approximately $5300 km^2$ over 6 years. . We also use a set of 603 ground truth samples of the following classes: "forest", "cotton-fallow", "soybean-cotton", "soybean-maize", and "soybean-millet".

\begin{figure}[!h]
\begin{center} 
  \includegraphics[width=\textwidth]{figure/study_area.png}
\end{center}
\caption{Study area in Mato Grosso, Brazil. The area was originally covered by tropical forest that has been removed given place to agricultural activities.}
\label{fig:study-area}
\end{figure}

\pkg{dtwSat} borrow the objects \code{RasterBrick} and \code{RasterStack} from the \pkg{raster} to handle with the satellite images time series. In the example bellow, we read the satellite images from the GTiff files in the folder *lucc\_MT/timeseries* using \code{raster::stack}. Each file includes vegetation indexes "ndvi", "evi", and original bands "nir", "red", "blue", and "mir" for one date.  EXPLAIN THE TIF FILES  This time information is also part of the name in the GTiff files, such as it usually comes from the data provider. We also need the images acquisition dates in the text file *lucc\_MT/timeseries/timeline*.
```{r, echo = TRUE, eval = TRUE}
library(dtwSat)
blue = brick(system.file("lucc_MT/timeseries/blue.tif",  package = "dtwSat"))
red  = brick(system.file("lucc_MT/timeseries/red.tif",  package = "dtwSat"))
nir  = brick(system.file("lucc_MT/timeseries/nir.tif",  package = "dtwSat"))
mir  = brick(system.file("lucc_MT/timeseries/mir.tif",  package = "dtwSat"))
evi  = brick(system.file("lucc_MT/timeseries/evi.tif",  package = "dtwSat"))
ndvi = brick(system.file("lucc_MT/timeseries/ndvi.tif",  package = "dtwSat"))
day_of_year = 
  brick(system.file("lucc_MT/timeseries/doy.tif", package = "dtwSat"))
dates = scan(system.file("lucc_MT/timeseries/timeline", package = "dtwSat"), 
             what = "dates")
```

The package \pkg{raster} does not support sequences of satellite measurements and multiple satellite attributes in the same object. Therefore we use the function \code{dtwSat::buildRasterTimeSeries} to build a raster time series with multiple satellite attributes. The inputs of this function area a list \code{raster::RasterStack} or \code{raster::RasterBrick} objects with the time series for each satellite attribute and the a vector with the images acquisition dates in the format \code{"YYYY-MM-DD"}. The raster objects in the list must have the same temporal and spatial extent. The resulting object is a list of raster objects with the time information that serves as input for our analysis. Note that to get a time series from several image files might become slow for bigger areas. Therefore, the function \code{buildRasterTimeSeries} also provides an interface to \code{raster::writeRaster} that creates independent files for each time series, *i.e.* it creates one file for each satellite attribute allowing us to use \code{RasterBrick} instead of \code{RasterStack} objects. As our example is small, we will use the \code{RasterStack} object. 
```{r, echo = TRUE, eval = TRUE}
raster_timeseries = 
  buildRasterTimeSeries(blue, red, nir, mir, evi, ndvi, 
                        timeline = dates, doy = day_of_year)
```

To build the temporal patterns for our land use classes we use the set of ground truth samples in the file *lucc\_MT/samples\_MT.shp*. Besides spatial locations, the shapefile provides the land use class (*class*) and the time period (*from*-*to*) of each sample. This dataset has a total of 603 samples that are: 68 Cotton-fallow, 138 Forest, 79 Soybean-cotton, 134 Soybean-maize, and 184 Soybean-millet. 
```{r, echo = TRUE, eval = TRUE}
field_samples = 
  read.csv(system.file("lucc_MT/samples.csv", package="dtwSat")) 
proj_str = scan(file = system.file("lucc_MT/samples_projection", package="dtwSat"), 
                what = "character")
```
```{r, echo = TRUE, eval = TRUE}
names(field_samples)
table(field_samples[["class"]])
```

We use the function \code{dtwSat::extractTimeSeries} to extract the time series for each sample from the raster time series in the list \code{raster_timeseries}. In this example, the time to extract 1 time series with 23 samples is \~0.3 seconds using 1 cores with 2.4 GHz clock. The output is a list of \code{zoo} objects, one for each sample in \code{field_samples}. 
```{r, echo = TRUE, eval = TRUE}
ts_list = extractTimeSeries(x = raster_timeseries, y = field_samples, 
                            proj4string = proj_str)
```

The samples time series in \code{ts_list} are the input to create the temporal patterns for each class using the function \code{dtwSat::createPattern}. This function fits a Generalized Additive Model (GAM) [@Wood:2011] to the samples and retrieves a smoothed temporal pattern. In the example below, we set \code{freq=8} to get temporal patterns with frequency of 8 days. We also use a cyclic cubic spline model \code{y ~ s(x, bs="cc")} as the fitting formula of the GAM (see \code{?mgcv::s} for details). 
```{r, echo = TRUE, eval = TRUE}
# Get class names 
class_names = as.character(unique(field_samples[["class"]]))
names(class_names) = class_names
# Split samples time series according to the class 
ts_class_samples = lapply(class_names, function(x){
  ts_list[field_samples[["class"]]==x]
})
# Apply createPattern for each class 
patterns_list = lapply(ts_class_samples, FUN = createPattern, 
                       freq = 8, formula = y ~ s(x, bs = "cc"))
```
This will give us the following temporal patterns 
```{r temporal-patterns, echo = TRUE, eval = TRUE, fig.path='figure/', fig.width=page_width, fig.height=page_width, fig.align='center', fig.pos='!h'}
plotPatterns(patterns_list) + theme(legend.position = "bottom")
```



```{r, echo = TRUE, eval = FALSE}
patterns_levels = c(seq_along(class_names), 255)
patterns_labels = c(class_names, "Unclassified")
land_use_maps = 
  twdtwApply(x = raster_timeseries, patterns = patterns_list, 
             mc.cores = 4, win.fun = classifyIntervals, 
             weight.fun = logisticWeight(alpha=-0.1, beta=50), 
             from = as.Date("2007-09-01"),to = as.Date("2013-09-01"),
             by = "12 month", overlap = 0.5, levels = patterns_levels,
             labels = patterns_labels, simplify= TRUE)
```
```{r, echo = FALSE, eval = TRUE}
# Load classification not to run again 
patterns_levels = c(seq_along(class_names), 255)
patterns_labels = c(class_names, "Unclassified")
land_use_maps = brick(system.file('lucc_MT/classification.tif', package = 'dtwSat'))
```

Lets now take a look at the classification results. This sequence of maps provided here is useful for land use changes analysis. Such results can be linked to other kind of datasets, *e.g.* commodities trading, and help in understanding the spatiotemporal connections of land use changes and its drivers. 
```{r plot-map, echo = TRUE, eval = TRUE, fig.path='figure/', fig.width=page_width, fig.align='center', fig.cap='Land use maps for each year from 2008 to 2013.', fig.pos='!h'}
patterns_colors = c("#996400", "#005500", "#D8B777", 
                    "#E6D219", "#E6BEC8", "#C8C8C8")
names(patterns_colors) = patterns_labels
plotLUCC(x = land_use_maps, type = "map", layer.labels = 2008:2013, 
         class.levels = patterns_levels, class.labels = patterns_labels, 
         class.colors = patterns_colors)
```

For example, we can quantify the accumulated land use changes over time, or even the land use transitions from and to each land class over time, such that
```{r plot-area, echo = TRUE, eval = TRUE, fig.path='figure/', fig.width=page_width, fig.align='center', fig.cap='Percentage of area for each land use class from 2008 to 2013.', fig.pos='!h'}
plotLUCC(x = land_use_maps, type = "area", layer.labels = 2008:2013, 
         class.levels = patterns_levels, class.labels = patterns_labels, 
         class.colors = patterns_colors)
```
```{r plot-change, echo = TRUE, eval = TRUE, fig.path='figure/', fig.width=page_width, fig.align='center', fig.cap='Percentage of land use changes for each year from 2008 to 2013.', fig.pos='!h'}
plotLUCC(x = land_use_maps, type = "change", layer.labels = 2008:2013, 
         class.levels = patterns_levels, class.labels = patterns_labels, 
         class.colors = patterns_colors)
```

## Accuracy assessment

Here we use our field samples to assess the accuracy of the classification using TWDTW. For that we split the sample of each class such that: 10% of the samples is used for training and 90% for validation. We run 100 simulation choosing random sample and compute the *user's* and *producer's accuracy*. These results are presented in Fig. (\ref{fig:plot-accuracy}). 

```{r, echo = TRUE, eval = FALSE}
# Split dataset for training and validation 
set.seed(1)
n = 2 # Number of repetitions 
reference = as.character(field_samples[["class"]])
splitted_dataset = splitDataset(timeseries = ts_list, ref = reference, 
      n=2, p=0.1, mc.cores=1, freq=8, from="2007-09-01", to="2008-09-01", 
      formula = y ~ s(time, bs="cc"))
assess_table = lapply(splitted_dataset, FUN=twdtwAssessment, overlap = 0.5, 
               weight.fun = logisticWeight(alpha=-0.1, beta=50), mc.cores=1)
```

```{r, echo = FALSE, eval = FALSE}
save(assess_list, file="./inst/lucc_MT/assess_list.RData")
```

```{r, echo = FALSE, eval = TRUE}
## Load classification not to run again 
load(system.file('lucc_MT/assessment.RData', package = 'dtwSat'))
```


```{r, echo = FALSE, eval = FALSE}
assess_results = do.call("rbind", assessment)
table(assess_results)
```


```{r, echo = FALSE, eval = TRUE}
assess_results = 
  do.call("rbind", lapply(assessment, function(class_table){
    assess_table = table(Predicted=class_table[["Predicted"]],
                         Reference=class_table[["Reference"]]
                         )
    user_accuracy = diag(assess_table) / rowSums(assess_table)
    prod_accuracy = diag(assess_table) / colSums(assess_table)
    data.frame(Group=names(user_accuracy), 
               User = user_accuracy,
               Producer = prod_accuracy
               )
}))
```


```{r plot-accuracy, echo = FALSE, eval = TRUE, fig.path='figure/', fig.width=page_width, fig.height=page_width/2, fig.align='center', fig.cap='Accuracy assessment of the of the land use classification using TWDTW.', fig.pos='!h'}
library(scales)
library(reshape2)
df = melt(assess_results, id="Group")
ggplot(df, aes(x=Group, y=value)) + 
  stat_summary(fun.data="median_hilow", width=0.5, 
               geom="crossbar", fill="grey") + 
  geom_point() +  facet_grid(. ~ variable) + 
  scale_y_continuous(limits = c(0,1), labels = percent) + 
  xlab("") + ylab("Accuracy") + coord_flip()
```



# References














