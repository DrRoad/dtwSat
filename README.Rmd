---
title: "dtwSat"
author: "Victor Maus"
date: "`r Sys.Date()`"
output:
  md_document:
    variant: markdown_github
bibliography: ./vignettes/references.bib
---


```{r, echo=FALSE}
knitr::opts_chunk$set(
  warning = FALSE,
  message = FALSE,
  error = FALSE
)
```


<!-- 
# Render README.md file  
rmarkdown::render("README.Rmd")
-->

dtwSat
=====

### Time-Weighted Dynamic Time Warping for remote sensing time series analysis
dtwSat provides an implementation of Time-Weighted Dynamic Time Warping (TWDTW) for satellite image time series analysis and land use classification [@Maus:2016]. It is useful to account for natural and cultivated vegetation types with inter-annual climatic and seasonal variability. Methods based on dynamic time warping are flexible to handle with irregular sampling and out of phase time series, and have achieved significant results in time series data mining [@Velichko:1970; @Sakoe:1971; @Sakoe:1978; @Rabiner:1993; @Berndt:1994; @Keogh:2005; @Muller:2007; @Petitjean:2012]. Bellow we show a quick demo of the package and some R vignettes about the package.

### Install
```{r installation, eval = FALSE}
devtools::install_github("vwmaus/dtwSat")
```


###Vignettes
<!--
* [Timw-Weighted Dynamic Time Warping - TWDTW]
* [Time series analysis using dtwSat]
-->
1. [Land use classification using dtwSat](ist/lucc.html)


```{r , echo = FALSE, eval = TRUE, warning = FALSE, message = FALSE}
k=1
```
### Quick demo
In this quick dome we will perform a TWDTW analysis for a single time series. Suppose that we want to know the crop type of each subinterval in following `template` time series:
```{r plot-template-ts, echo = TRUE, eval = TRUE, fig.path='figure/', fig.width=6, fig.height=2, fig.align='center', warning = FALSE, message = FALSE, fig.cap=paste0('Fig. ',k,'. Template time series.')}
library(dtwSat)
library(ggplot2)
autoplot(template, facets = NULL) + 
     theme(text = element_text(size = 8, family = "Helvetica"))
```
```{r , echo = FALSE, eval = TRUE, warning = FALSE, message = FALSE}
k=k+1
```

We know that in the region where the time series was observed we have *soybean*, *cotton*, and *maize*, whose typical temporal pattern are:
```{r plot-patterns, echo = TRUE, eval = TRUE, fig.path='figure/', fig.width=6, fig.height=2, fig.align='center', warning = FALSE, message = FALSE, fig.cap=paste0('Fig. ',k,'. Typical temporal patterns of *soybean*, *cotton*, and *maize*.')}
plotPatterns(patterns.list) + 
     theme(text = element_text(size = 8, family = "Helvetica"))
```
```{r , echo = FALSE, eval = TRUE, warning = FALSE, message = FALSE}
k=k+1
```

Using the these temporal patterns we run the TWDTW analysis, such that 
```{r perform-twdtw, echo = TRUE, eval = TRUE, results = "hide", warning = FALSE, message = FALSE}
weight.fun = logisticWeight(alpha=-0.1, beta=100) # Logistic time-weight
alig = twdtw(x=template, patterns=patterns.list, 
             normalize.patterns = TRUE, patterns.length = 23,
             weight.fun = weight.fun, keep=TRUE) 
```

The result is a `twdtw` object with all possible matches of the patterns to the time series 
```{r show-twdtw, echo = TRUE, eval = TRUE, results = "hide", warning = FALSE, message = FALSE}
class(alig)
print(alig)
summary(alig)
```

We can use several plot methods to visualize the `twdtw` object. To plot alignments 
```{r plot-alignment, echo = TRUE, eval = TRUE, fig.path='figure/', fig.width=6, fig.height=4, fig.align='center', warning = FALSE, message = FALSE, fig.cap=paste0('Fig. ',k,'. TWDTW alignments over time and cost (distance) in y-axis.')}
plot(x = alig, type = "alignment") + 
     theme(text = element_text(size = 8, family = "Helvetica"))
```
```{r , echo = FALSE, eval = TRUE, warning = FALSE, message = FALSE}
k=k+1
```
to plot matching point 
```{r plot-match, echo = TRUE, eval = TRUE, fig.path='figure/', fig.width=6, fig.height=4, fig.align='center', warning = FALSE, message = FALSE, fig.cap=paste0('Fig. ',k,'. The best match for each crop type.')}
plot(x = alig, type = "match", attr = "evi") + 
     theme(text = element_text(size = 8, family = "Helvetica"))
```
```{r , echo = FALSE, eval = TRUE, warning = FALSE, message = FALSE}
k=k+1
```
to plot minimum cost paths 
```{r plot-path, echo = TRUE, eval = TRUE, fig.path='figure/', fig.width=6, fig.height=6, fig.align='center', warning = FALSE, message = FALSE, fig.cap=paste0('Fig. ',k,'. The minimum cost path of the TWDTW alignment for each crop type.')}
plot(type = "path", x = alig) + 
     theme(text = element_text(size = 8, family = "Helvetica"))
```
```{r , echo = FALSE, eval = TRUE, warning = FALSE, message = FALSE}
k=k+1
```
and, finally to classify the subintervals of the template time series 
```{r plot-group, echo = TRUE, eval = TRUE, fig.path='figure/', fig.width=6, fig.height=2, fig.align='center', warning = FALSE, message = FALSE, fig.cap=paste0('Fig. ',k,'. Classification using the best match for each subinterval.')}
plot(x = alig, type = "group",
     from = "2009-09-01", to = "2013-09-01", 
     by = "6 month", overlap = 0.3) + 
     theme(text = element_text(size = 8, family = "Helvetica"))
```
```{r , echo = FALSE, eval = TRUE, warning = FALSE, message = FALSE}
k=k+1
```

To see more example please check the [R vignettes][Vignettes] and if you want to learn more about the TWDTW method see Maus et al. [-@Maus:2016]

### References

